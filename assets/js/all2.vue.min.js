const { createApp: e, ref: a, onMounted: l, computed: t, watch: s, nextTick: r } = Vue, TMDB_API_KEY = "6b4357c41d9c606e4d7ebe2f4a8850ea", TMDB_BASE_URL = "https://api.themoviedb.org/3", TMDB_IMAGE_BASE_URL = "https://image.tmdb.org/t/p/"; let jwPlayerInstance = null; e({ setup() { let e = a(GStreamInit.tmdb), u = a({}), o = a(null), n = a([]), i = a(!0), d = a(!1), v = a(null), p = a(null), b = a(null), m = a(!1), c = a(null), h = a([]), w = a(!1), y = a(null), $ = a(null), g = a(null), f = a(null), I = a({ dubbed: [], subtitled: [] }), _ = a(!1), E = a(null), j = t(() => { if (!u.value.seasons) return []; let e = u.value.seasons.filter(e => e.season_number >= 1 && e.episode_count > 0 && e.season_number <= (u.value.last_episode_to_air ? u.value.last_episode_to_air.season_number : 1 / 0)); return e.sort((e, a) => e.season_number - a.season_number) }), P = t(() => { let e = I.value; return "dubbed" === f.value ? e.dubbed || [] : "subtitled" === f.value && e.subtitled || [] }), A = async () => { i.value = !0, v.value = null; try { let e = await GStreamInit.getSeasons(); if (!e.ok) throw Error(`Erro ao buscar s\xe9rie: ${e.status} ${e.statusText}`); if (u.value = await e.json(), u.value = function e(a) { let l = { number_of_seasons: a.length, number_of_episodes: a.flat().length, seasons: [] }; return a.forEach((e, a) => { let t = a + 1, s = { air_date: null, episode_count: e.length, id: `season-${t}`, name: `Temporada ${t}`, overview: null, poster_path: null, season_number: t, episodes: [] }; e.forEach((e, a) => { let l = a + 1; s.episodes.push({ id: `ep-${t}-${l}`, episode_number: l, season_number: t, name: e.title || `Epis\xf3dio ${l}`, overview: e.overview || null, still_path: e.image || null, dubbed_servers: e.dubbed || [], subtitled_servers: e.subtitled || [] }) }), l.seasons.push(s) }), l }(u.value[0]), V(), u.value.seasons && j.value.length > 0) { let a = j.value[0].season_number; if (g.value && j.value.some(e => e.season_number === g.value.seasonNumber)) a = g.value.seasonNumber; else { let l = u.value.last_episode_to_air ? u.value.last_episode_to_air.season_number : null; l && j.value.some(e => e.season_number === l) && (a = l) } o.value = a, await M(o.value) } } catch (t) { v.value = "N\xe3o foi poss\xedvel carregar os detalhes da s\xe9rie.", console.error("Erro ao buscar detalhes da s\xe9rie:", t) } finally { i.value = !1 } }, M = async a => { d.value = !0, p.value = null; try { let l = u.value.seasons.find(e => e.season_number === a); if (!l) throw Error(`Temporada ${a} n\xe3o encontrada nos dados da sua API.`); let t = l.episodes, s = {}; try { let o = await fetch(`https://api.themoviedb.org/3/tv/${e.value}/season/${a}?api_key=60410b05df5500653b897116d2357fdd&language=pt-BR`); if (o.ok) { let i = await o.json(); i.episodes?.forEach(e => { s[e.episode_number] = e }) } else console.warn(`TMDB retornou erro para temporada ${a}:`, o.status) } catch (v) { console.warn("Erro ao buscar dados do TMDB, seguindo apenas com dados da API principal:", v) } n.value = t.map(e => { let l = e.episode_number, t = s[l] || {}; return { id: `ep-${a}-${l}`, episode_number: l, season_number: a, name: t.name || e.name || `Epis\xf3dio ${l}`, overview: t.overview || e.overview || "", still_path: t.still_path ? `${TMDB_IMAGE_BASE_URL}original${t.still_path}` : e.still_path && e.still_path.startsWith("http") ? e.still_path : "", dubbed: e.dubbed_servers || [], subtitled: e.subtitled_servers || [], image: e.still_path && e.still_path.startsWith("http") ? e.still_path : t.still_path ? `${TMDB_IMAGE_BASE_URL}original${t.still_path}` : "" } }) } catch (b) { p.value = "Erro ao carregar epis\xf3dios. Verifique sua API e TMDB.", console.error("Erro ao buscar epis\xf3dios:", b) } finally { d.value = !1, g.value && g.value.seasonNumber === a && r(() => { let e = document.querySelector(`.episode-card:nth-child(${g.value.episodeNumber})`); e && e.scrollIntoView({ behavior: "smooth", block: "center" }) }) } }, B = async e => { o.value !== e && (jwPlayerInstance && (jwPlayerInstance.remove(), jwPlayerInstance = null), b.value = null, m.value = !1, c.value = null, $.value = null, f.value = null, I.value = { dubbed: [], subtitled: [] }, o.value = e, await M(o.value)) }, N = e => e && e.startsWith("http") ? e : e ? `${TMDB_IMAGE_BASE_URL}w300${e}` : "https://via.placeholder.com/300x170?text=Imagem+N%C3%A3o+Dispon%C3%ADvel", T = e => { e.target.src = "https://via.placeholder.com/300x170?text=Imagem+N%C3%A3o+Dispon%C3%ADvel", e.target.onerror = null }, D = async e => { c.value = e, m.value = !1, w.value = !0, y.value = null, f.value = null, I.value = { dubbed: [], subtitled: [] }, _.value = !0, jwPlayerInstance && (jwPlayerInstance.remove(), jwPlayerInstance = null); try { await new Promise(e => setTimeout(e, 500)), I.value.dubbed = e.dubbed || [], I.value.subtitled = e.subtitled || []; let a = I.value.dubbed.length > 0, l = I.value.subtitled.length > 0, t = null; if (a && l ? t = null : a ? t = "dubbed" : l && (t = "subtitled"), t) { f.value = t, await r(); let s = I.value[t] || []; if (1 === s.length) { x(s[0]); return } } t && !(serversForLang.length > 1) && (a || l) || (a || l || (y.value = "Nenhuma op\xe7\xe3o de \xe1udio/legenda dispon\xedvel para este epis\xf3dio."), m.value = !0) } catch (u) { y.value = "N\xe3o foi poss\xedvel carregar as op\xe7\xf5es de \xe1udio/legenda.", console.error("Erro ao processar op\xe7\xf5es de stream:", u), m.value = !0 } finally { w.value = !1, _.value = !1 } }, S = async e => { f.value = e, await r(), 1 === h.value.length && x(h.value[0]) }, x = e => { $.value = e, b.value = c.value, m.value = !1, U(o.value, c.value.episode_number, c.value.name) }, W = async e => { try { let a = await GStreamInit.getStream(e); if (!a.ok) throw Error(`Erro ao buscar stream: ${a.status} ${a.statusText}`); let l = await a.json(); if (l.break) throw L(), Error("Stream n\xe3o dispon\xedvel ou erro na resposta da API."); let t = l.resources || {}; if (!t.iframe && (!t.sources || 0 === t.sources.length)) throw Error("Nenhum servidor de stream dispon\xedvel."); return t.sources[0].file } catch (s) { return console.error("Erro ao buscar URL de stream:", s), "https://www.youtube.com/embed/WRxwtV_x8nM?autoplay=1" } }, R = async e => { try { let a = await GStreamInit.getStream(e); if (!a.ok) throw Error(`Erro ao buscar stream: ${a.status} ${a.statusText}`); let l = await a.json(); if (l.break) throw L(), Error("Stream n\xe3o dispon\xedvel ou erro na resposta da API."); return l } catch (t) { return console.error("Erro ao buscar stream:", t), "https://www.youtube.com/embed/WRxwtV_x8nM?autoplay=1" } }, k = () => { m.value = !1, c.value = null, y.value = null, f.value = null, I.value = { dubbed: [], subtitled: [] } }, L = () => { jwPlayerInstance && (jwPlayerInstance.remove(), jwPlayerInstance = null), b.value = null, $.value = null }, U = (a, l, t) => { let s = { seasonNumber: a, episodeNumber: l, episodeName: t, seriesId: e.value }; localStorage.setItem(`lastWatchedEpisode_${e.value}`, JSON.stringify(s)), g.value = s }, V = () => { let a = localStorage.getItem(`lastWatchedEpisode_${e.value}`); a && (g.value = JSON.parse(a)) }, C = () => { localStorage.removeItem(`lastWatchedEpisode_${e.value}`), g.value = null }, G = async e => { E.value = await W(e) }; return s($, async e => { if (jwPlayerInstance && (jwPlayerInstance.remove(), jwPlayerInstance = null), e && e.type && "MP4" === e.type.name) { let a = await R(e); console.log(a.resources.sources), r(() => { window.jwplayer ? jwPlayerInstance = window.jwplayer("jwplayer-container").setup({ width: "100%", height: "100%", autoplay: !0, title: c.value.name, image: N(c.value.still_path || c.value.image).replace("w300", "original"), ...a.players.jwplayer, ...a.resources }) : console.error("JWPlayer n\xe3o est\xe1 dispon\xedvel. Verifique se o script foi carregado corretamente.") }) } e && e.type && "Iframe" === e.type.name && (E.value = G(e)) }, { immediate: !1 }), l(() => { A() }), { series: u, selectedSeasonNumber: o, episodes: n, loadingSeries: i, loadingEpisodes: d, errorSeries: v, errorEpisodes: p, filteredSeasons: j, currentEpisode: b, showServerSelection: m, selectedEpisodeForServer: c, availableServers: P, loadingServers: w, errorServers: y, selectedServer: $, lastWatched: g, episodeStreams: I, selectedLanguageOption: f, showGlobalLoading: _, selectSeason: B, getEpisodeStillUrl: N, handleImageError: T, initiateEpisodePlay: D, selectLanguageOption: S, selectServer: x, getStreamUrl: W, streamUrl: E, closeServerSelection: k, backToList: L, clearLastWatched: C, isLastWatched: a => g.value && g.value.seriesId === e.value && g.value.seasonNumber === o.value && g.value.episodeNumber === a } } }).mount("#app");